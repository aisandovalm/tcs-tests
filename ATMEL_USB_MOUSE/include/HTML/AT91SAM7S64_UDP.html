<html><head>
<meta charset="iso-8859-1" content="Arm / ATMEL/ AT91 library / AT91SAM7S64" http-equiv="Content-Type">
<title>Hardware API Selector: AT91SAM7S64 Definitions</title>
</head>
<h1>USB Device Interface Peripheral</h1>
<null><a name="UDP"></a><b>UDP</b> <i><font size="-1">(<a href="AT91SAM7S64_h.html#AT91S_UDP">AT91S_UDP</a>)</font></i><b>  0xFFFB0000 </b><i><font size="-1">(<a href="AT91SAM7S64_h.html#AT91C_BASE_UDP">AT91C_BASE_UDP</a>)</font></i>
<table border=1 cellpadding=3 cellspacing=0><null><th bgcolor="#FFFFCC"><font size="-1">Periph ID <a href="#AIC">AIC</a></font></th><th bgcolor="#FFFFCC"><font size="-1">Symbol</font></th><th bgcolor="#FFFFCC"><font size="-1">Description</font></th><tr><td bgcolor="#FFFFCC"><font size="-1"><b>11</b> </font></td><td><font size="-1"><i><font size="-1">(<a href="AT91SAM7S64_h.html#AT91C_ID_UDP">AT91C_ID_UDP</a>)</font></i></font></td><td><font size="-1">USB Device Port</font></td></tr>
</null></table><br><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><font size="-1"><b>Function</b></font></th><th bgcolor="#FFFFCC"><font size="-1"><b>Description</b></font></th><tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_CfgPMC">AT91F_UDP_CfgPMC</a></b></font></td><td><font size="-1">Enable Peripheral clock in PMC for UDP</font></td></tr>
</null></table><br><br></null><a name="UDP"></a><h2>UDP Software API <i><font size="-1">(<a href="AT91SAM7S64_h.html#AT91S_UDP">AT91S_UDP</a>)</font></i></h2>
<a name="UDP"></a><null><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><font size="-1"><b>Offset</b></font></th><th bgcolor="#FFFFCC"><font size="-1"><b>Field</b></font></th><th bgcolor="#FFFFCC"><font size="-1"><b>Description</b></font></th>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x0</b></font></td><td><font size="-1">UDP_NUM (<a href="AT91SAM7S64_UDP.html#UDP_FRM_NUM">UDP_FRM_NUM</a>)</font></td><td><font size="-1">Frame Number Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x4</b></font></td><td><font size="-1">UDP_GLBSTATE (<a href="#UDP_GLB_STATE">UDP_GLB_STATE</a>)</font></td><td><font size="-1">Global State Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x8</b></font></td><td><font size="-1"><a href="AT91SAM7S64_UDP.html#UDP_FADDR">UDP_FADDR</a></font></td><td><font size="-1">Function Address Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x10</b></font></td><td><font size="-1"><a href="AT91SAM7S64_UDP.html#UDP_IER">UDP_IER</a></font></td><td><font size="-1">Interrupt Enable Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x14</b></font></td><td><font size="-1"><a href="AT91SAM7S64_UDP.html#UDP_IDR">UDP_IDR</a></font></td><td><font size="-1">Interrupt Disable Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x18</b></font></td><td><font size="-1"><a href="AT91SAM7S64_UDP.html#UDP_IMR">UDP_IMR</a></font></td><td><font size="-1">Interrupt Mask Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x1C</b></font></td><td><font size="-1"><a href="AT91SAM7S64_UDP.html#UDP_ISR">UDP_ISR</a></font></td><td><font size="-1">Interrupt Status Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x20</b></font></td><td><font size="-1"><a href="AT91SAM7S64_UDP.html#UDP_ICR">UDP_ICR</a></font></td><td><font size="-1">Interrupt Clear Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x28</b></font></td><td><font size="-1">UDP_RSTEP (<a href="#UDP_RST_EP">UDP_RST_EP</a>)</font></td><td><font size="-1">Reset Endpoint Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x30</b></font></td><td><font size="-1">UDP_CSR[8] (<a href="AT91SAM7S64_UDP.html#UDP_CSR">UDP_CSR</a>)</font></td><td><font size="-1">Endpoint Control and Status Register</font></td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC"><font size="-1"><b>0x50</b></font></td><td><font size="-1">UDP_FDR[8] (<a href="AT91SAM7S64_UDP.html#UDP_FDR">UDP_FDR</a>)</font></td><td><font size="-1">Endpoint FIFO Data Register</font></td></tr>
</null></table><br><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><font size="-1"><b>Function</b></font></th><th bgcolor="#FFFFCC"><font size="-1"><b>Description</b></font></th><tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_EpClear">AT91F_UDP_EpClear</a></b></font></td><td><font size="-1">Clear flag in the endpoint CSR register</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_ResetEp">AT91F_UDP_ResetEp</a></b></font></td><td><font size="-1">Reset UDP endpoint</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_EpWrite">AT91F_UDP_EpWrite</a></b></font></td><td><font size="-1">Write value in the DPR</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_EnableIt">AT91F_UDP_EnableIt</a></b></font></td><td><font size="-1">Enable UDP IT</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_EpSet">AT91F_UDP_EpSet</a></b></font></td><td><font size="-1">Set flag in the endpoint CSR register</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_DisableEp">AT91F_UDP_DisableEp</a></b></font></td><td><font size="-1">Enable Endpoint</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_EpStall">AT91F_UDP_EpStall</a></b></font></td><td><font size="-1">Endpoint will STALL requests</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_EpRead">AT91F_UDP_EpRead</a></b></font></td><td><font size="-1">Return value from the DPR</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_SetAddress">AT91F_UDP_SetAddress</a></b></font></td><td><font size="-1">Set UDP functional address</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_EpStatus">AT91F_UDP_EpStatus</a></b></font></td><td><font size="-1">Return the endpoint CSR register</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_IsInterruptMasked">AT91F_UDP_IsInterruptMasked</a></b></font></td><td><font size="-1">Test if UDP Interrupt is Masked </font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_GetInterruptMaskStatus">AT91F_UDP_GetInterruptMaskStatus</a></b></font></td><td><font size="-1">Return UDP Interrupt Mask Status</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_GetState">AT91F_UDP_GetState</a></b></font></td><td><font size="-1">return UDP Device state</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_SetState">AT91F_UDP_SetState</a></b></font></td><td><font size="-1">Set UDP Device state</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_EnableEp">AT91F_UDP_EnableEp</a></b></font></td><td><font size="-1">Enable Endpoint</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_EpEndOfWr">AT91F_UDP_EpEndOfWr</a></b></font></td><td><font size="-1">Notify the UDP that values in DPR are ready to be sent</font></td></tr>
<tr><td bgcolor="#FFFFCC"><font size="-1"><b><a href="lib_AT91SAM7S64_h.html#AT91F_UDP_DisableIt">AT91F_UDP_DisableIt</a></b></font></td><td><font size="-1">Disable UDP IT</font></td></tr>
</null></table></null><h2>UDP Register Description</h2>
<null><a name="UDP_FRM_NUM"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_FRM_NUM  <i>Frame Number Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_NUM">AT91C_UDP_NUM</a></i> 0xFFFB0000</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">10..0</td><td align="CENTER"><a name="UDP_FRM_NUM"></a><b>UDP_FRM_NUM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_FRM_NUM">AT91C_UDP_FRM_NUM</a></font></td><td><b>Frame Number as Defined in the Packet Field Formats</b><br>This 11-bit value is incremented by the host on a per frame basis. This value is updated at each start of frame. Value Updated at the SOF_EOP(Start of Frame End of Packet).</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">16</td><td align="CENTER"><a name="UDP_FRM_ERR"></a><b>UDP_FRM_ERR</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_FRM_ERR">AT91C_UDP_FRM_ERR</a></font></td><td><b>Frame Error</b><br>This bit is set at SOF_EOP when the SOF packet is received containing an error.<br>This bit is reset upon receipt of SOF_PID.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">17</td><td align="CENTER"><a name="UDP_FRM_OK"></a><b>UDP_FRM_OK</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_FRM_OK">AT91C_UDP_FRM_OK</a></font></td><td><b>Frame OK</b><br>This bit is set at SOF_EOP when the SOF packet is received without any error.<br>This bit is reset upon receipt of SOF_PID (Packet Identification).<br>In the Interrupt Status Register, the SOF interrupt is updated upon receiving SOF_PID. This bit is set without waiting for EOP.<br>Note: In the 8-bit Register Interface, FRM_OK is bit 4 of FRM_NUM_H and FRM_ERR is bit 3 of FRM_NUM_L.</td></tr>
</null></table>
<a name="UDP_GLBSTATE"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_GLBSTATE  <i>Global State Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_GLBSTATE">AT91C_UDP_GLBSTATE</a></i> 0xFFFB0004</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">0</td><td align="CENTER"><a name="UDP_FADDEN"></a><b>UDP_FADDEN</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_FADDEN">AT91C_UDP_FADDEN</a></font></td><td><b>Function Address Enable</b><br>Read:<br>0 = Device is not in address state.<br>1 = Device is in address state.<br>Write:<br>0 = No effect, only a reset can bring back a device to the default state.<br>1 = Set device in address state. This occurs after a successful Set Address request. Beforehand, the USB_FADDR register must have been initialized with Set Address parameters. Set Address must complete the Status Stage before setting FAD-DEN. Please refer to chapter 9 of the Universal Serial Bus Specification, Rev. 1.1 to get more details.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">1</td><td align="CENTER"><a name="UDP_CONFG"></a><b>UDP_CONFG</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_CONFG">AT91C_UDP_CONFG</a></font></td><td><b>Configured</b><br>Read:<br>0 = Device is not in configured state.<br>1 = Device is in configured state.<br>Write:<br>0 = Set device in a nonconfigured state<br>1 = Set device in configured state.<br>The device is set in configured state when it is in address state and receives a successful Set Configuration request. Please refer to Chapter 9 of the Universal Serial Bus Specification, Rev. 1.1 to get more details.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">2</td><td align="CENTER"><a name="UDP_RMWUPE"></a><b>UDP_RMWUPE</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RMWUPE">AT91C_UDP_RMWUPE</a></font></td><td><b>Remote Wake Up Enable</b><br>0 = Disable function's remote wake up.<br>1 = Enable function's remote wake up.<br>This bit is set if the function's remote wake up feature is enabled. When an asynchronous rising edge is detected on send_resume pin, if RMWUPE = 1, then a RESUME state is sent to the host.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">3</td><td align="CENTER"><a name="UDP_RSMINPR"></a><b>UDP_RSMINPR</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RSMINPR">AT91C_UDP_RSMINPR</a></font></td><td><b>A Resume Has Been Sent to the Host</b><br>Read:<br>0 = No effect.<br>1 = A Resume has been received from the host during Remote Wake Up feature.</td></tr>
</null></table>
<a name="UDP_FADDR"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_FADDR  <i>Function Address Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_FADDR">AT91C_UDP_FADDR</a></i> 0xFFFB0008</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">7..0</td><td align="CENTER"><a name="UDP_FADD"></a><b>UDP_FADD</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_FADD">AT91C_UDP_FADD</a></font></td><td><b>Function Address Value</b><br>The Function Address Value must be programmed by firmware once the device receives a set address request from the host, and has achieved the status stage of the no-data control sequence. Please refer to the Universal Serial Bus Specifica-tion, Rev. 1.1 to get more information. After power up, or reset, the function address value is set to 0.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">8</td><td align="CENTER"><a name="UDP_FEN"></a><b>UDP_FEN</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_FEN">AT91C_UDP_FEN</a></font></td><td><b>Function Enable</b><br>Read:<br>0 = Function endpoint disabled.<br>1 = Function endpoint enabled.<br>Write:<br>0 = Disable function endpoint.<br>1 = Default value.<br>The Function Enable bit (FEN) allows the microcontroller to enable or disable the function endpoints. The microcontroller will set this bit after receipt of a reset from the host. Once this bit is set, the USB device is able to accept and transfer data packets from and to the host.</td></tr>
</null></table>
<a name="UDP_IER"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_IER  <i>Interrupt Enable Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_IER">AT91C_UDP_IER</a></i> 0xFFFB0010</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">0</td><td align="CENTER"><a name="UDP_EPINT0"></a><b>UDP_EPINT0</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT0">AT91C_UDP_EPINT0</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint0 Interrupt pending.<br>1 = Endpoint0 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR0:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP0INT is a sticky bit. Interrupt remains valid until EP0INT is cleared by writing in the corresponding USB_CSR0 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">1</td><td align="CENTER"><a name="UDP_EPINT1"></a><b>UDP_EPINT1</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT1">AT91C_UDP_EPINT1</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint1 Interrupt pending.<br>1 = Endpoint1 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR1:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP1INT is a sticky bit. Interrupt remains valid until EP1INT is cleared by writing in the corresponding USB_CSR1 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">2</td><td align="CENTER"><a name="UDP_EPINT2"></a><b>UDP_EPINT2</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT2">AT91C_UDP_EPINT2</a></font></td><td><b>Endpoint 2 Interrupt</b><br>0 = No Endpoint2 Interrupt pending.<br>1 = Endpoint2 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR2:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP2INT is a sticky bit. Interrupt remains valid until EP2INT is cleared by writing in the corresponding USB_CSR2 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">3</td><td align="CENTER"><a name="UDP_EPINT3"></a><b>UDP_EPINT3</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT3">AT91C_UDP_EPINT3</a></font></td><td><b>Endpoint 3 Interrupt</b><br>0 = No Endpoint3 Interrupt pending.<br>1 = Endpoint3 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR3:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP3INT is a sticky bit. Interrupt remains valid until EP3INT is cleared by writing in the corresponding USB_CSR3 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">4</td><td align="CENTER"><a name="UDP_EPINT4"></a><b>UDP_EPINT4</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT4">AT91C_UDP_EPINT4</a></font></td><td><b>Endpoint 4 Interrupt</b><br>0 = No Endpoint4 Interrupt pending.<br>1 = Endpoint4 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR4:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP4INT is a sticky bit. Interrupt remains valid until EP4INT is cleared by writing in the corresponding USB_CSR4 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">5</td><td align="CENTER"><a name="UDP_EPINT5"></a><b>UDP_EPINT5</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT5">AT91C_UDP_EPINT5</a></font></td><td><b>Endpoint 5 Interrupt</b><br>0 = No Endpoint5 Interrupt pending.<br>1 = Endpoint5 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR5:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP5INT is a sticky bit. Interrupt remains valid until EP5INT is cleared by writing in the corresponding USB_CSR5 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">6</td><td align="CENTER"><a name="UDP_EPINT6"></a><b>UDP_EPINT6</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT6">AT91C_UDP_EPINT6</a></font></td><td><b>Endpoint 6 Interrupt</b><br>0 = No Endpoint6 Interrupt pending.<br>1 = Endpoint6 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR6:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP6INT is a sticky bit. Interrupt remains valid until EP6INT is cleared by writing in the corresponding USB_CSR6 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">7</td><td align="CENTER"><a name="UDP_EPINT7"></a><b>UDP_EPINT7</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT7">AT91C_UDP_EPINT7</a></font></td><td><b>Endpoint 7 Interrupt</b><br>0 = No Endpoint7 Interrupt pending.<br>1 = Endpoint7 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR7:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP7INT is a sticky bit. Interrupt remains valid until EP7INT is cleared by writing in the corresponding USB_CSR7 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">8</td><td align="CENTER"><a name="UDP_RXSUSP"></a><b>UDP_RXSUSP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXSUSP">AT91C_UDP_RXSUSP</a></font></td><td><b>USB Suspend Interrupt</b><br>0 = No USB Suspend Interrupt pending.<br>1 = USB Suspend Interrupt has been raised.<br>The USB device sets this bit when it detects no activity for 3ms. The USB device enters Suspend mode.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">9</td><td align="CENTER"><a name="UDP_RXRSM"></a><b>UDP_RXRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXRSM">AT91C_UDP_RXRSM</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No USB Resume Interrupt pending.<br>1 =USB Resume Interrupt has been raised.<br>The USB device sets this bit when a USB resume signal is detected at its port.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">10</td><td align="CENTER"><a name="UDP_EXTRSM"></a><b>UDP_EXTRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EXTRSM">AT91C_UDP_EXTRSM</a></font></td><td><b>USB External Resume Interrupt</b><br>0 = No External Resume Interrupt pending.<br>1 = External Resume Interrupt has been raised.<br>This interrupt is raised when, in suspend mode, an asynchronous rising edge on the send_resume is detected. If RMWUPE = 1, a resume state is sent in the USB bus.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">11</td><td align="CENTER"><a name="UDP_SOFINT"></a><b>UDP_SOFINT</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_SOFINT">AT91C_UDP_SOFINT</a></font></td><td><b>USB Start Of frame Interrupt</b><br>0 = No Start of Frame Interrupt pending.<br>1 = Start of Frame Interrupt has been raised.<br>This interrupt is raised each time a SOF token has been detected. It can be used as a synchronization signal by using isochronous endpoints.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">13</td><td align="CENTER"><a name="UDP_WAKEUP"></a><b>UDP_WAKEUP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_WAKEUP">AT91C_UDP_WAKEUP</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No Wakeup Interrupt pending.<br>1 = A Wakeup Interrupt (USB Host Sent a RESUME or RESET) occurred since the last clear.</td></tr>
</null></table>
<a name="UDP_IDR"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_IDR  <i>Interrupt Disable Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_IDR">AT91C_UDP_IDR</a></i> 0xFFFB0014</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">0</td><td align="CENTER"><a name="UDP_EPINT0"></a><b>UDP_EPINT0</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT0">AT91C_UDP_EPINT0</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint0 Interrupt pending.<br>1 = Endpoint0 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR0:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP0INT is a sticky bit. Interrupt remains valid until EP0INT is cleared by writing in the corresponding USB_CSR0 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">1</td><td align="CENTER"><a name="UDP_EPINT1"></a><b>UDP_EPINT1</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT1">AT91C_UDP_EPINT1</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint1 Interrupt pending.<br>1 = Endpoint1 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR1:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP1INT is a sticky bit. Interrupt remains valid until EP1INT is cleared by writing in the corresponding USB_CSR1 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">2</td><td align="CENTER"><a name="UDP_EPINT2"></a><b>UDP_EPINT2</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT2">AT91C_UDP_EPINT2</a></font></td><td><b>Endpoint 2 Interrupt</b><br>0 = No Endpoint2 Interrupt pending.<br>1 = Endpoint2 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR2:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP2INT is a sticky bit. Interrupt remains valid until EP2INT is cleared by writing in the corresponding USB_CSR2 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">3</td><td align="CENTER"><a name="UDP_EPINT3"></a><b>UDP_EPINT3</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT3">AT91C_UDP_EPINT3</a></font></td><td><b>Endpoint 3 Interrupt</b><br>0 = No Endpoint3 Interrupt pending.<br>1 = Endpoint3 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR3:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP3INT is a sticky bit. Interrupt remains valid until EP3INT is cleared by writing in the corresponding USB_CSR3 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">4</td><td align="CENTER"><a name="UDP_EPINT4"></a><b>UDP_EPINT4</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT4">AT91C_UDP_EPINT4</a></font></td><td><b>Endpoint 4 Interrupt</b><br>0 = No Endpoint4 Interrupt pending.<br>1 = Endpoint4 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR4:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP4INT is a sticky bit. Interrupt remains valid until EP4INT is cleared by writing in the corresponding USB_CSR4 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">5</td><td align="CENTER"><a name="UDP_EPINT5"></a><b>UDP_EPINT5</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT5">AT91C_UDP_EPINT5</a></font></td><td><b>Endpoint 5 Interrupt</b><br>0 = No Endpoint5 Interrupt pending.<br>1 = Endpoint5 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR5:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP5INT is a sticky bit. Interrupt remains valid until EP5INT is cleared by writing in the corresponding USB_CSR5 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">6</td><td align="CENTER"><a name="UDP_EPINT6"></a><b>UDP_EPINT6</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT6">AT91C_UDP_EPINT6</a></font></td><td><b>Endpoint 6 Interrupt</b><br>0 = No Endpoint6 Interrupt pending.<br>1 = Endpoint6 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR6:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP6INT is a sticky bit. Interrupt remains valid until EP6INT is cleared by writing in the corresponding USB_CSR6 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">7</td><td align="CENTER"><a name="UDP_EPINT7"></a><b>UDP_EPINT7</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT7">AT91C_UDP_EPINT7</a></font></td><td><b>Endpoint 7 Interrupt</b><br>0 = No Endpoint7 Interrupt pending.<br>1 = Endpoint7 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR7:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP7INT is a sticky bit. Interrupt remains valid until EP7INT is cleared by writing in the corresponding USB_CSR7 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">8</td><td align="CENTER"><a name="UDP_RXSUSP"></a><b>UDP_RXSUSP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXSUSP">AT91C_UDP_RXSUSP</a></font></td><td><b>USB Suspend Interrupt</b><br>0 = No USB Suspend Interrupt pending.<br>1 = USB Suspend Interrupt has been raised.<br>The USB device sets this bit when it detects no activity for 3ms. The USB device enters Suspend mode.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">9</td><td align="CENTER"><a name="UDP_RXRSM"></a><b>UDP_RXRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXRSM">AT91C_UDP_RXRSM</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No USB Resume Interrupt pending.<br>1 =USB Resume Interrupt has been raised.<br>The USB device sets this bit when a USB resume signal is detected at its port.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">10</td><td align="CENTER"><a name="UDP_EXTRSM"></a><b>UDP_EXTRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EXTRSM">AT91C_UDP_EXTRSM</a></font></td><td><b>USB External Resume Interrupt</b><br>0 = No External Resume Interrupt pending.<br>1 = External Resume Interrupt has been raised.<br>This interrupt is raised when, in suspend mode, an asynchronous rising edge on the send_resume is detected. If RMWUPE = 1, a resume state is sent in the USB bus.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">11</td><td align="CENTER"><a name="UDP_SOFINT"></a><b>UDP_SOFINT</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_SOFINT">AT91C_UDP_SOFINT</a></font></td><td><b>USB Start Of frame Interrupt</b><br>0 = No Start of Frame Interrupt pending.<br>1 = Start of Frame Interrupt has been raised.<br>This interrupt is raised each time a SOF token has been detected. It can be used as a synchronization signal by using isochronous endpoints.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">13</td><td align="CENTER"><a name="UDP_WAKEUP"></a><b>UDP_WAKEUP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_WAKEUP">AT91C_UDP_WAKEUP</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No Wakeup Interrupt pending.<br>1 = A Wakeup Interrupt (USB Host Sent a RESUME or RESET) occurred since the last clear.</td></tr>
</null></table>
<a name="UDP_IMR"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_IMR  <i>Interrupt Mask Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_IMR">AT91C_UDP_IMR</a></i> 0xFFFB0018</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">0</td><td align="CENTER"><a name="UDP_EPINT0"></a><b>UDP_EPINT0</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT0">AT91C_UDP_EPINT0</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint0 Interrupt pending.<br>1 = Endpoint0 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR0:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP0INT is a sticky bit. Interrupt remains valid until EP0INT is cleared by writing in the corresponding USB_CSR0 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">1</td><td align="CENTER"><a name="UDP_EPINT1"></a><b>UDP_EPINT1</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT1">AT91C_UDP_EPINT1</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint1 Interrupt pending.<br>1 = Endpoint1 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR1:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP1INT is a sticky bit. Interrupt remains valid until EP1INT is cleared by writing in the corresponding USB_CSR1 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">2</td><td align="CENTER"><a name="UDP_EPINT2"></a><b>UDP_EPINT2</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT2">AT91C_UDP_EPINT2</a></font></td><td><b>Endpoint 2 Interrupt</b><br>0 = No Endpoint2 Interrupt pending.<br>1 = Endpoint2 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR2:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP2INT is a sticky bit. Interrupt remains valid until EP2INT is cleared by writing in the corresponding USB_CSR2 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">3</td><td align="CENTER"><a name="UDP_EPINT3"></a><b>UDP_EPINT3</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT3">AT91C_UDP_EPINT3</a></font></td><td><b>Endpoint 3 Interrupt</b><br>0 = No Endpoint3 Interrupt pending.<br>1 = Endpoint3 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR3:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP3INT is a sticky bit. Interrupt remains valid until EP3INT is cleared by writing in the corresponding USB_CSR3 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">4</td><td align="CENTER"><a name="UDP_EPINT4"></a><b>UDP_EPINT4</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT4">AT91C_UDP_EPINT4</a></font></td><td><b>Endpoint 4 Interrupt</b><br>0 = No Endpoint4 Interrupt pending.<br>1 = Endpoint4 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR4:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP4INT is a sticky bit. Interrupt remains valid until EP4INT is cleared by writing in the corresponding USB_CSR4 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">5</td><td align="CENTER"><a name="UDP_EPINT5"></a><b>UDP_EPINT5</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT5">AT91C_UDP_EPINT5</a></font></td><td><b>Endpoint 5 Interrupt</b><br>0 = No Endpoint5 Interrupt pending.<br>1 = Endpoint5 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR5:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP5INT is a sticky bit. Interrupt remains valid until EP5INT is cleared by writing in the corresponding USB_CSR5 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">6</td><td align="CENTER"><a name="UDP_EPINT6"></a><b>UDP_EPINT6</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT6">AT91C_UDP_EPINT6</a></font></td><td><b>Endpoint 6 Interrupt</b><br>0 = No Endpoint6 Interrupt pending.<br>1 = Endpoint6 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR6:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP6INT is a sticky bit. Interrupt remains valid until EP6INT is cleared by writing in the corresponding USB_CSR6 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">7</td><td align="CENTER"><a name="UDP_EPINT7"></a><b>UDP_EPINT7</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT7">AT91C_UDP_EPINT7</a></font></td><td><b>Endpoint 7 Interrupt</b><br>0 = No Endpoint7 Interrupt pending.<br>1 = Endpoint7 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR7:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP7INT is a sticky bit. Interrupt remains valid until EP7INT is cleared by writing in the corresponding USB_CSR7 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">8</td><td align="CENTER"><a name="UDP_RXSUSP"></a><b>UDP_RXSUSP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXSUSP">AT91C_UDP_RXSUSP</a></font></td><td><b>USB Suspend Interrupt</b><br>0 = No USB Suspend Interrupt pending.<br>1 = USB Suspend Interrupt has been raised.<br>The USB device sets this bit when it detects no activity for 3ms. The USB device enters Suspend mode.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">9</td><td align="CENTER"><a name="UDP_RXRSM"></a><b>UDP_RXRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXRSM">AT91C_UDP_RXRSM</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No USB Resume Interrupt pending.<br>1 =USB Resume Interrupt has been raised.<br>The USB device sets this bit when a USB resume signal is detected at its port.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">10</td><td align="CENTER"><a name="UDP_EXTRSM"></a><b>UDP_EXTRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EXTRSM">AT91C_UDP_EXTRSM</a></font></td><td><b>USB External Resume Interrupt</b><br>0 = No External Resume Interrupt pending.<br>1 = External Resume Interrupt has been raised.<br>This interrupt is raised when, in suspend mode, an asynchronous rising edge on the send_resume is detected. If RMWUPE = 1, a resume state is sent in the USB bus.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">11</td><td align="CENTER"><a name="UDP_SOFINT"></a><b>UDP_SOFINT</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_SOFINT">AT91C_UDP_SOFINT</a></font></td><td><b>USB Start Of frame Interrupt</b><br>0 = No Start of Frame Interrupt pending.<br>1 = Start of Frame Interrupt has been raised.<br>This interrupt is raised each time a SOF token has been detected. It can be used as a synchronization signal by using isochronous endpoints.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">13</td><td align="CENTER"><a name="UDP_WAKEUP"></a><b>UDP_WAKEUP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_WAKEUP">AT91C_UDP_WAKEUP</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No Wakeup Interrupt pending.<br>1 = A Wakeup Interrupt (USB Host Sent a RESUME or RESET) occurred since the last clear.</td></tr>
</null></table>
<a name="UDP_ISR"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_ISR  <i>Interrupt Status Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_ISR">AT91C_UDP_ISR</a></i> 0xFFFB001C</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">0</td><td align="CENTER"><a name="UDP_EPINT0"></a><b>UDP_EPINT0</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT0">AT91C_UDP_EPINT0</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint0 Interrupt pending.<br>1 = Endpoint0 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR0:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP0INT is a sticky bit. Interrupt remains valid until EP0INT is cleared by writing in the corresponding USB_CSR0 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">1</td><td align="CENTER"><a name="UDP_EPINT1"></a><b>UDP_EPINT1</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT1">AT91C_UDP_EPINT1</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint1 Interrupt pending.<br>1 = Endpoint1 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR1:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP1INT is a sticky bit. Interrupt remains valid until EP1INT is cleared by writing in the corresponding USB_CSR1 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">2</td><td align="CENTER"><a name="UDP_EPINT2"></a><b>UDP_EPINT2</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT2">AT91C_UDP_EPINT2</a></font></td><td><b>Endpoint 2 Interrupt</b><br>0 = No Endpoint2 Interrupt pending.<br>1 = Endpoint2 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR2:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP2INT is a sticky bit. Interrupt remains valid until EP2INT is cleared by writing in the corresponding USB_CSR2 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">3</td><td align="CENTER"><a name="UDP_EPINT3"></a><b>UDP_EPINT3</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT3">AT91C_UDP_EPINT3</a></font></td><td><b>Endpoint 3 Interrupt</b><br>0 = No Endpoint3 Interrupt pending.<br>1 = Endpoint3 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR3:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP3INT is a sticky bit. Interrupt remains valid until EP3INT is cleared by writing in the corresponding USB_CSR3 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">4</td><td align="CENTER"><a name="UDP_EPINT4"></a><b>UDP_EPINT4</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT4">AT91C_UDP_EPINT4</a></font></td><td><b>Endpoint 4 Interrupt</b><br>0 = No Endpoint4 Interrupt pending.<br>1 = Endpoint4 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR4:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP4INT is a sticky bit. Interrupt remains valid until EP4INT is cleared by writing in the corresponding USB_CSR4 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">5</td><td align="CENTER"><a name="UDP_EPINT5"></a><b>UDP_EPINT5</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT5">AT91C_UDP_EPINT5</a></font></td><td><b>Endpoint 5 Interrupt</b><br>0 = No Endpoint5 Interrupt pending.<br>1 = Endpoint5 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR5:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP5INT is a sticky bit. Interrupt remains valid until EP5INT is cleared by writing in the corresponding USB_CSR5 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">6</td><td align="CENTER"><a name="UDP_EPINT6"></a><b>UDP_EPINT6</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT6">AT91C_UDP_EPINT6</a></font></td><td><b>Endpoint 6 Interrupt</b><br>0 = No Endpoint6 Interrupt pending.<br>1 = Endpoint6 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR6:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP6INT is a sticky bit. Interrupt remains valid until EP6INT is cleared by writing in the corresponding USB_CSR6 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">7</td><td align="CENTER"><a name="UDP_EPINT7"></a><b>UDP_EPINT7</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT7">AT91C_UDP_EPINT7</a></font></td><td><b>Endpoint 7 Interrupt</b><br>0 = No Endpoint7 Interrupt pending.<br>1 = Endpoint7 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR7:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP7INT is a sticky bit. Interrupt remains valid until EP7INT is cleared by writing in the corresponding USB_CSR7 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">8</td><td align="CENTER"><a name="UDP_RXSUSP"></a><b>UDP_RXSUSP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXSUSP">AT91C_UDP_RXSUSP</a></font></td><td><b>USB Suspend Interrupt</b><br>0 = No USB Suspend Interrupt pending.<br>1 = USB Suspend Interrupt has been raised.<br>The USB device sets this bit when it detects no activity for 3ms. The USB device enters Suspend mode.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">9</td><td align="CENTER"><a name="UDP_RXRSM"></a><b>UDP_RXRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXRSM">AT91C_UDP_RXRSM</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No USB Resume Interrupt pending.<br>1 =USB Resume Interrupt has been raised.<br>The USB device sets this bit when a USB resume signal is detected at its port.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">10</td><td align="CENTER"><a name="UDP_EXTRSM"></a><b>UDP_EXTRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EXTRSM">AT91C_UDP_EXTRSM</a></font></td><td><b>USB External Resume Interrupt</b><br>0 = No External Resume Interrupt pending.<br>1 = External Resume Interrupt has been raised.<br>This interrupt is raised when, in suspend mode, an asynchronous rising edge on the send_resume is detected. If RMWUPE = 1, a resume state is sent in the USB bus.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">11</td><td align="CENTER"><a name="UDP_SOFINT"></a><b>UDP_SOFINT</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_SOFINT">AT91C_UDP_SOFINT</a></font></td><td><b>USB Start Of frame Interrupt</b><br>0 = No Start of Frame Interrupt pending.<br>1 = Start of Frame Interrupt has been raised.<br>This interrupt is raised each time a SOF token has been detected. It can be used as a synchronization signal by using isochronous endpoints.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">12</td><td align="CENTER"><a name="UDP_ENDBUSRES"></a><b>UDP_ENDBUSRES</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_ENDBUSRES">AT91C_UDP_ENDBUSRES</a></font></td><td><b>USB End Of Bus Reset Interrupt</b><br>0 = No End of Bus Reset Interrupt pending.<br>1 = End of Bus Reset Interrupt has been raised.<br>This interrupt is raised at the end of a USB reset sequence. The USB device must prepare to receive requests on the end-point 0. The host will start the enumeration, then will perform the configuration.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">13</td><td align="CENTER"><a name="UDP_WAKEUP"></a><b>UDP_WAKEUP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_WAKEUP">AT91C_UDP_WAKEUP</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No Wakeup Interrupt pending.<br>1 = A Wakeup Interrupt (USB Host Sent a RESUME or RESET) occurred since the last clear.</td></tr>
</null></table>
<a name="UDP_ICR"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_ICR  <i>Interrupt Clear Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_ICR">AT91C_UDP_ICR</a></i> 0xFFFB0020</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">0</td><td align="CENTER"><a name="UDP_EPINT0"></a><b>UDP_EPINT0</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT0">AT91C_UDP_EPINT0</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint0 Interrupt pending.<br>1 = Endpoint0 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR0:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP0INT is a sticky bit. Interrupt remains valid until EP0INT is cleared by writing in the corresponding USB_CSR0 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">1</td><td align="CENTER"><a name="UDP_EPINT1"></a><b>UDP_EPINT1</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT1">AT91C_UDP_EPINT1</a></font></td><td><b>Endpoint 0 Interrupt</b><br>0 = No Endpoint1 Interrupt pending.<br>1 = Endpoint1 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR1:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP1INT is a sticky bit. Interrupt remains valid until EP1INT is cleared by writing in the corresponding USB_CSR1 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">2</td><td align="CENTER"><a name="UDP_EPINT2"></a><b>UDP_EPINT2</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT2">AT91C_UDP_EPINT2</a></font></td><td><b>Endpoint 2 Interrupt</b><br>0 = No Endpoint2 Interrupt pending.<br>1 = Endpoint2 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR2:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP2INT is a sticky bit. Interrupt remains valid until EP2INT is cleared by writing in the corresponding USB_CSR2 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">3</td><td align="CENTER"><a name="UDP_EPINT3"></a><b>UDP_EPINT3</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT3">AT91C_UDP_EPINT3</a></font></td><td><b>Endpoint 3 Interrupt</b><br>0 = No Endpoint3 Interrupt pending.<br>1 = Endpoint3 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR3:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP3INT is a sticky bit. Interrupt remains valid until EP3INT is cleared by writing in the corresponding USB_CSR3 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">4</td><td align="CENTER"><a name="UDP_EPINT4"></a><b>UDP_EPINT4</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT4">AT91C_UDP_EPINT4</a></font></td><td><b>Endpoint 4 Interrupt</b><br>0 = No Endpoint4 Interrupt pending.<br>1 = Endpoint4 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR4:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP4INT is a sticky bit. Interrupt remains valid until EP4INT is cleared by writing in the corresponding USB_CSR4 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">5</td><td align="CENTER"><a name="UDP_EPINT5"></a><b>UDP_EPINT5</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT5">AT91C_UDP_EPINT5</a></font></td><td><b>Endpoint 5 Interrupt</b><br>0 = No Endpoint5 Interrupt pending.<br>1 = Endpoint5 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR5:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP5INT is a sticky bit. Interrupt remains valid until EP5INT is cleared by writing in the corresponding USB_CSR5 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">6</td><td align="CENTER"><a name="UDP_EPINT6"></a><b>UDP_EPINT6</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT6">AT91C_UDP_EPINT6</a></font></td><td><b>Endpoint 6 Interrupt</b><br>0 = No Endpoint6 Interrupt pending.<br>1 = Endpoint6 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR6:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP6INT is a sticky bit. Interrupt remains valid until EP6INT is cleared by writing in the corresponding USB_CSR6 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">7</td><td align="CENTER"><a name="UDP_EPINT7"></a><b>UDP_EPINT7</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPINT7">AT91C_UDP_EPINT7</a></font></td><td><b>Endpoint 7 Interrupt</b><br>0 = No Endpoint7 Interrupt pending.<br>1 = Endpoint7 Interrupt has been raised.<br>Several signals can generate this interrupt. The reason can be found by reading USB_CSR7:<br>RXSETUP set to 1<br>RX_DATA_BK0 set to 1<br>RX_DATA_BK1 set to 1<br>TXCOMP set to 1<br>STALLSENT set to 1<br>EP7INT is a sticky bit. Interrupt remains valid until EP7INT is cleared by writing in the corresponding USB_CSR7 bit.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">8</td><td align="CENTER"><a name="UDP_RXSUSP"></a><b>UDP_RXSUSP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXSUSP">AT91C_UDP_RXSUSP</a></font></td><td><b>USB Suspend Interrupt</b><br>0 = No USB Suspend Interrupt pending.<br>1 = USB Suspend Interrupt has been raised.<br>The USB device sets this bit when it detects no activity for 3ms. The USB device enters Suspend mode.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">9</td><td align="CENTER"><a name="UDP_RXRSM"></a><b>UDP_RXRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXRSM">AT91C_UDP_RXRSM</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No USB Resume Interrupt pending.<br>1 =USB Resume Interrupt has been raised.<br>The USB device sets this bit when a USB resume signal is detected at its port.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">10</td><td align="CENTER"><a name="UDP_EXTRSM"></a><b>UDP_EXTRSM</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EXTRSM">AT91C_UDP_EXTRSM</a></font></td><td><b>USB External Resume Interrupt</b><br>0 = No External Resume Interrupt pending.<br>1 = External Resume Interrupt has been raised.<br>This interrupt is raised when, in suspend mode, an asynchronous rising edge on the send_resume is detected. If RMWUPE = 1, a resume state is sent in the USB bus.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">11</td><td align="CENTER"><a name="UDP_SOFINT"></a><b>UDP_SOFINT</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_SOFINT">AT91C_UDP_SOFINT</a></font></td><td><b>USB Start Of frame Interrupt</b><br>0 = No Start of Frame Interrupt pending.<br>1 = Start of Frame Interrupt has been raised.<br>This interrupt is raised each time a SOF token has been detected. It can be used as a synchronization signal by using isochronous endpoints.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">13</td><td align="CENTER"><a name="UDP_WAKEUP"></a><b>UDP_WAKEUP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_WAKEUP">AT91C_UDP_WAKEUP</a></font></td><td><b>USB Resume Interrupt</b><br>0 = No Wakeup Interrupt pending.<br>1 = A Wakeup Interrupt (USB Host Sent a RESUME or RESET) occurred since the last clear.</td></tr>
</null></table>
<a name="UDP_RSTEP"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_RSTEP  <i>Reset Endpoint Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_RSTEP">AT91C_UDP_RSTEP</a></i> 0xFFFB0028</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">0</td><td align="CENTER"><a name="UDP_EP0"></a><b>UDP_EP0</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EP0">AT91C_UDP_EP0</a></font></td><td><b>Reset Endpoint 0</b><br>0 = No effect.<br>1 = Reset endpoint.<br>Endpoint reset clears all flags in USB_CSR0.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">1</td><td align="CENTER"><a name="UDP_EP1"></a><b>UDP_EP1</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EP1">AT91C_UDP_EP1</a></font></td><td><b>Reset Endpoint 1</b><br>0 = No effect.<br>1 = Reset endpoint.<br>Endpoint reset clears all flags in USB_CSR1.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">2</td><td align="CENTER"><a name="UDP_EP2"></a><b>UDP_EP2</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EP2">AT91C_UDP_EP2</a></font></td><td><b>Reset Endpoint 2</b><br>0 = No effect.<br>1 = Reset endpoint.<br>Endpoint reset clears all flags in USB_CSR2.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">3</td><td align="CENTER"><a name="UDP_EP3"></a><b>UDP_EP3</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EP3">AT91C_UDP_EP3</a></font></td><td><b>Reset Endpoint 3</b><br>0 = No effect.<br>1 = Reset endpoint.<br>Endpoint reset clears all flags in USB_CSR3.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">4</td><td align="CENTER"><a name="UDP_EP4"></a><b>UDP_EP4</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EP4">AT91C_UDP_EP4</a></font></td><td><b>Reset Endpoint 4</b><br>0 = No effect.<br>1 = Reset endpoint.<br>Endpoint reset clears all flags in USB_CSR4.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">5</td><td align="CENTER"><a name="UDP_EP5"></a><b>UDP_EP5</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EP5">AT91C_UDP_EP5</a></font></td><td><b>Reset Endpoint 5</b><br>0 = No effect.<br>1 = Reset endpoint.<br>Endpoint reset clears all flags in USB_CSR5.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">6</td><td align="CENTER"><a name="UDP_EP6"></a><b>UDP_EP6</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EP6">AT91C_UDP_EP6</a></font></td><td><b>Reset Endpoint 6</b><br>0 = No effect.<br>1 = Reset endpoint.<br>Endpoint reset clears all flags in USB_CSR6.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">7</td><td align="CENTER"><a name="UDP_EP7"></a><b>UDP_EP7</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EP7">AT91C_UDP_EP7</a></font></td><td><b>Reset Endpoint 7</b><br>0 = No effect.<br>1 = Reset endpoint.<br>Endpoint reset clears all flags in USB_CSR7.</td></tr>
</null></table>
<a name="UDP_CSR"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_CSR  <i>Endpoint Control and Status Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_CSR">AT91C_UDP_CSR</a></i> 0xFFFB0030</font></null></ul><table border=1 cellpadding=0 cellspacing=0 width="100%"><null><th bgcolor="#FFFFCC"><b>Offset</b></th><th bgcolor="#FFFFCC"><b>Name</b></th><th bgcolor="#FFFFCC"><b>Description</b></th><tr><td align="CENTER" bgcolor="#FFFFCC">0</td><td align="CENTER"><a name="UDP_TXCOMP"></a><b>UDP_TXCOMP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_TXCOMP">AT91C_UDP_TXCOMP</a></font></td><td><b>Generates an IN packet with data previously written in the DPR</b><br>This flag generates an interrupt while it is set to one.<br>Write (Cleared by the firmware)<br>0 = Clear the flag, clear the interrupt.<br>1 = No effect.<br>Read (Set by the USB peripheral)<br>0 = Data IN transaction has not been acknowledged by the Host.<br>1 = Data IN transaction is achieved, acknowledged by the Host.<br>After having issued a Data IN transaction setting TXPKTREADY, the device firmware waits for TXCOMP to be sure that the host has acknowledged the transaction.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">1</td><td align="CENTER"><a name="UDP_RX_DATA_BK0"></a><b>UDP_RX_DATA_BK0</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RX_DATA_BK0">AT91C_UDP_RX_DATA_BK0</a></font></td><td><b>Receive Data Bank 0</b><br>This flag generates an interrupt while it is set to one.<br>Write (Cleared by the firmware)<br>0 = Notify USB peripheral device that data have been read in the FIFO's Bank 0.<br>1 = No effect.<br>Read (Set by the USB peripheral)<br>0 = No data packet has been received in the FIFO's Bank 0<br>1 = A data packet has been received, it has been stored in the FIFO's Bank 0.<br>When the device firmware has polled this bit or has been interrupted by this signal, it must transfer data from the FIFO to the microcontroller memory. The number of bytes received is available in RXBYTCENT field. Bank 0 FIFO values are read through the USB_FDRx register. Once a transfer is done, the device firmware must release Bank 0 to the USB peripheral device by clearing RX_DATA_BK0.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">2</td><td align="CENTER"><a name="UDP_RXSETUP"></a><b>UDP_RXSETUP</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXSETUP">AT91C_UDP_RXSETUP</a></font></td><td><b>Sends STALL to the Host (Control endpoints)</b><br>This flag generates an interrupt while it is set to one.<br>Read<br>0 = No setup packet available.<br>1 = A setup data packet has been sent by the host and is available in the FIFO.<br>Write<br>0 = Device firmware notifies the USB peripheral device that it has read the setup data in the FIFO.<br>1 = No effect.<br>This flag is used to notify the USB device firmware that a valid Setup data packet has been sent by the host and success-fully received by the USB device. The USB device firmware may transfer Setup data from the FIFO by reading the USB_FDRx register to the microcontroller memory. Once a transfer has been done, RXSETUP must be cleared by the device firmware.<br>Ensuing Data OUT transactions will not be accepted while RXSETUP is set.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">3</td><td align="CENTER"><a name="UDP_ISOERROR"></a><b>UDP_ISOERROR</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_ISOERROR">AT91C_UDP_ISOERROR</a></font></td><td><b>Isochronous error (Isochronous endpoints)</b><br>A CRC error has been detected in an isochronous transfer<br>Read<br>0 = No error in the previous isochronous transfer.<br>1 = CRC error has been detected, data available in the FIFO are corrupted.<br>Write<br>0 = reset the ISOERROR flag, clear the interrupt.<br>1 = No effect.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">4</td><td align="CENTER"><a name="UDP_TXPKTRDY"></a><b>UDP_TXPKTRDY</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_TXPKTRDY">AT91C_UDP_TXPKTRDY</a></font></td><td><b>Transmit Packet Ready</b><br>This flag is cleared by the USB device.<br>This flag is set by the USB device firmware.<br>Read<br>0 = Data values can be written in the FIFO.<br>1 = Data values can not be written in the FIFO.<br>Write<br>0 = No effect.<br>1 = A new data payload is has been written in the FIFO by the firmware and is ready to be sent.<br>This flag is used to generate a Data IN transaction (device to host). Device firmware checks that it can write a data payload in the FIFO, checking that TXPKTREADY is cleared. Transfer to the FIFO is done by writing in the USB_FDRx register. Once the data payload has been transferred to the FIFO, the firmware notifies the USB device setting TXPKTREADY to one. USB bus transactions can start. TXCOMP is set once the data payload has been received by the host.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">5</td><td align="CENTER"><a name="UDP_FORCESTALL"></a><b>UDP_FORCESTALL</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_FORCESTALL">AT91C_UDP_FORCESTALL</a></font></td><td><b>Force Stall (used by Control, Bulk and Isochronous endpoints).</b><br>Write-only<br>0 = No effect.<br>1 = Send STALL to the host.<br>Please refer to chapters 8.4.4 and 9.4.5 of the Universal Serial Bus Specification, Rev. 1.1 to get more information on the STALL handshake.<br>Control endpoints: during the data stage and status stage, this indicates that the microcontroller can not complete the request.<br>Bulk and interrupt endpoints: notify the host that the endpoint is halted.<br>The host acknowledges the STALL, device firmware is notified by the STALLSENT flag.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">6</td><td align="CENTER"><a name="UDP_RX_DATA_BK1"></a><b>UDP_RX_DATA_BK1</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RX_DATA_BK1">AT91C_UDP_RX_DATA_BK1</a></font></td><td><b>Receive Data Bank 1 (only used by endpoints with ping-pong attributes).</b><br>This flag generates an interrupt while it is set to one.<br>Write (Cleared by the firmware)<br>0 = Notify USB device that data have been read in the FIFO&#146;s Bank 1.<br>1 = No effect.<br>Read (Set by the USB peripheral)<br>0 = No data packet has been received in the FIFO's Bank 1.<br>1 = A data packet has been received, it has been stored in FIFO's Bank 1.<br>When the device firmware has polled this bit or has been interrupted by this signal, it must transfer data from the FIFO to microcontroller memory. The number of bytes received is available in RXBYTECNT field. Bank 1 FIFO values are read through USB_FDRx register. Once a transfer is done, the device firmware must release Bank 1 to the USB device by clear-ing RX_DATA_BK1.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">7</td><td align="CENTER"><a name="UDP_DIR"></a><b>UDP_DIR</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_DIR">AT91C_UDP_DIR</a></font></td><td><b>Transfer Direction</b><br>0 = Allow Data OUT transactions in the control data stage.<br>1 = Enable Data IN transactions in the control data stage.<br>Please refer to Chapter 8.5.2 of the Universal Serial Bus Specification, Rev. 1.1 to get more information on the control data stage.<br>This bit must be set after the end of the setup stage. According to the request sent in the setup data packet, the data stage<br>will either be a device to host (DIR = 1) or host to device (DIR = 0) data transfer. It is not necessary to check this bit to reverse direction for the status stage.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">10..8</td><td align="CENTER"><a name="UDP_EPTYPE"></a><b>UDP_EPTYPE</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPTYPE">AT91C_UDP_EPTYPE</a></font></td><td><b>Endpoint type</b><font size="-1"><table bgcolor="#E3F2FF" border=1 cellpadding=0 cellspacing=0 width="100%"><null><th><b>Value</b></th><th><b>Label</b></th><th><b>Description</b></th><tr><td align="CENTER">0</td><td align="CENTER"><a name="UDP_EPTYPE_CTRL"></a><b>UDP_EPTYPE_CTRL</b><font size="-1"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPTYPE_CTRL">AT91C_UDP_EPTYPE_CTRL</a></font></td><td><br>Control</td></tr>
<tr><td align="CENTER">1</td><td align="CENTER"><a name="UDP_EPTYPE_ISO_OUT"></a><b>UDP_EPTYPE_ISO_OUT</b><font size="-1"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPTYPE_ISO_OUT">AT91C_UDP_EPTYPE_ISO_OUT</a></font></td><td><br>Isochronous OUT</td></tr>
<tr><td align="CENTER">2</td><td align="CENTER"><a name="UDP_EPTYPE_BULK_OUT"></a><b>UDP_EPTYPE_BULK_OUT</b><font size="-1"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPTYPE_BULK_OUT">AT91C_UDP_EPTYPE_BULK_OUT</a></font></td><td><br>Bulk OUT</td></tr>
<tr><td align="CENTER">3</td><td align="CENTER"><a name="UDP_EPTYPE_INT_OUT"></a><b>UDP_EPTYPE_INT_OUT</b><font size="-1"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPTYPE_INT_OUT">AT91C_UDP_EPTYPE_INT_OUT</a></font></td><td><br>Interrupt OUT</td></tr>
<tr><td align="CENTER">5</td><td align="CENTER"><a name="UDP_EPTYPE_ISO_IN"></a><b>UDP_EPTYPE_ISO_IN</b><font size="-1"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPTYPE_ISO_IN">AT91C_UDP_EPTYPE_ISO_IN</a></font></td><td><br>Isochronous IN</td></tr>
<tr><td align="CENTER">6</td><td align="CENTER"><a name="UDP_EPTYPE_BULK_IN"></a><b>UDP_EPTYPE_BULK_IN</b><font size="-1"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPTYPE_BULK_IN">AT91C_UDP_EPTYPE_BULK_IN</a></font></td><td><br>Bulk IN</td></tr>
<tr><td align="CENTER">7</td><td align="CENTER"><a name="UDP_EPTYPE_INT_IN"></a><b>UDP_EPTYPE_INT_IN</b><font size="-1"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPTYPE_INT_IN">AT91C_UDP_EPTYPE_INT_IN</a></font></td><td><br>Interrupt IN</td></tr>
</null></table></font>
</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">11</td><td align="CENTER"><a name="UDP_DTGLE"></a><b>UDP_DTGLE</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_DTGLE">AT91C_UDP_DTGLE</a></font></td><td><b>Data Toggle</b><br>Read-only<br>0 = Identifies DATA0 packet.<br>1 = Identifies DATA1 packet.<br>Please refer to Chapter 8 of the Universal Serial Bus Specification, Rev. 1.1 to get more information on DATA0, DATA1 packet definitions.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">15</td><td align="CENTER"><a name="UDP_EPEDS"></a><b>UDP_EPEDS</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_EPEDS">AT91C_UDP_EPEDS</a></font></td><td><b>Endpoint Enable Disable</b><br>Read<br>0 = Endpoint disabled.<br>1 = Endpoint enabled.<br>Write<br>0 = Disable endpoint.<br>1 = Enable endpoint.</td></tr>
<tr><td align="CENTER" bgcolor="#FFFFCC">26..16</td><td align="CENTER"><a name="UDP_RXBYTECNT"></a><b>UDP_RXBYTECNT</b><font size="-2"><br><a href="AT91SAM7S64_h.html#AT91C_UDP_RXBYTECNT">AT91C_UDP_RXBYTECNT</a></font></td><td><b>Number Of Bytes Available in the FIFO</b><br>Read-only.<br>When the host sends a data packet to the device, the USB device stores the data in the FIFO and notifies the microcontrol-ler. The microcontroller can load the data from the FIFO by reading RXBYTECENT bytes in the USB_FDRx register.</td></tr>
</null></table>
<a name="UDP_FDR"></a><h4><a href="#UDP">UDP</a>: <i><a href="AT91SAM7S64_h.html#AT91_REG">AT91_REG</a></i> UDP_FDR  <i>Endpoint FIFO Data Register</i></h4><ul><null><font size="-2"><li><b>UDP</b> <i><a href="AT91SAM7S64_h.html#AT91C_UDP_FDR">AT91C_UDP_FDR</a></i> 0xFFFB0050</font></null></ul><br>FIFO data value.<br>The microcontroller can push or pop values in the FIFO through this register. RXBYTECNT in the corresponding USB_CSRx register is the number of bytes to be read from the FIFO (sent by the host). The maximum number of bytes to write is fixed by the Max Packet Size in the Standard Endpoint Descriptor. It can not be more than the physical memory size associated to the endpoint. Please refer to the Universal Serial Bus Specification, Rev. 1.1 to get more information.</null><hr></html>
